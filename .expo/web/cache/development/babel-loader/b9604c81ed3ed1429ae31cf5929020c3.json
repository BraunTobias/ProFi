{"ast":null,"code":"var getArea = function getArea(a, b) {\n  return a * b;\n};\n\nvar getPointDistance = function getPointDistance(a, b) {\n  return Math.sqrt(Math.pow(a[0] - b[0], 2) + Math.pow(a[1] - b[1], 2));\n};\n\nexport var getElementVisibleWidth = function getElementVisibleWidth(elementWidth, xOffset, ScreenWidth) {\n  if (xOffset >= 0) {\n    return xOffset + elementWidth <= ScreenWidth ? elementWidth : ScreenWidth - xOffset;\n  }\n\n  return elementWidth - xOffset;\n};\n\nvar getTooltipCoordinate = function getTooltipCoordinate(x, y, width, height, ScreenWidth, ScreenHeight, tooltipWidth, tooltipHeight, withPointer) {\n  var center = [x + getElementVisibleWidth(width, x, ScreenWidth) / 2, y + height / 2];\n  var pOne = [center[0], 0];\n  var pTwo = [ScreenWidth, center[1]];\n  var pThree = [center[0], ScreenHeight];\n  var pFour = [0, center[1]];\n  var vOne = getPointDistance(center, pOne);\n  var vTwo = getPointDistance(center, pTwo);\n  var vThree = getPointDistance(center, pThree);\n  var vFour = getPointDistance(center, pFour);\n  var areas = [getArea(vOne, vFour), getArea(vOne, vTwo), getArea(vTwo, vThree), getArea(vThree, vFour)].map(function (each, index) {\n    return {\n      area: each,\n      id: index\n    };\n  });\n  var sortedArea = areas.sort(function (a, b) {\n    return b.area - a.area;\n  });\n  var dX = 0.001;\n  var dY = height / 2;\n  var directionCorrection = [[-1, -1], [1, -1], [1, 1], [-1, 1]];\n  var deslocateReferencePoint = [[-tooltipWidth, -tooltipHeight], [0, -tooltipHeight], [0, 0], [-tooltipWidth, 0]];\n  var qIndex = sortedArea[0].id;\n\n  var getWithPointerOffsetY = function getWithPointerOffsetY() {\n    return withPointer ? 10 * directionCorrection[qIndex][1] : 0;\n  };\n\n  var getWithPointerOffsetX = function getWithPointerOffsetX() {\n    return withPointer ? center[0] - 18 * directionCorrection[qIndex][0] : center[0];\n  };\n\n  var newX = getWithPointerOffsetX() + (dX * directionCorrection[qIndex][0] + deslocateReferencePoint[qIndex][0]);\n  return {\n    x: constraintX(newX, qIndex, center[0], ScreenWidth, tooltipWidth),\n    y: center[1] + (dY * directionCorrection[qIndex][1] + deslocateReferencePoint[qIndex][1]) + getWithPointerOffsetY()\n  };\n};\n\nvar constraintX = function constraintX(newX, qIndex, x, ScreenWidth, tooltipWidth) {\n  switch (qIndex) {\n    case 0:\n    case 3:\n      {\n        var maxWidth = newX > ScreenWidth ? ScreenWidth - 10 : newX;\n        return newX < 1 ? 10 : maxWidth;\n      }\n\n    case 1:\n    case 2:\n      {\n        var leftOverSpace = ScreenWidth - newX;\n        return leftOverSpace >= tooltipWidth ? newX : newX - (tooltipWidth - leftOverSpace + 10);\n      }\n\n    default:\n      {\n        return 0;\n      }\n  }\n};\n\nexport default getTooltipCoordinate;","map":{"version":3,"sources":["C:/Users/Kira/Documents/University/MS6/MobileSysteme/MOSY/node_modules/react-native-elements/src/tooltip/getTooltipCoordinate.js"],"names":["getArea","a","b","getPointDistance","Math","sqrt","pow","getElementVisibleWidth","elementWidth","xOffset","ScreenWidth","getTooltipCoordinate","x","y","width","height","ScreenHeight","tooltipWidth","tooltipHeight","withPointer","center","pOne","pTwo","pThree","pFour","vOne","vTwo","vThree","vFour","areas","map","each","index","area","id","sortedArea","sort","dX","dY","directionCorrection","deslocateReferencePoint","qIndex","getWithPointerOffsetY","getWithPointerOffsetX","newX","constraintX","maxWidth","leftOverSpace"],"mappings":"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","sourcesContent":["const getArea = (a, b) => a * b;\r\n\r\nconst getPointDistance = (a, b) =>\r\n  Math.sqrt(Math.pow(a[0] - b[0], 2) + Math.pow(a[1] - b[1], 2));\r\n\r\nexport const getElementVisibleWidth = (elementWidth, xOffset, ScreenWidth) => {\r\n  // Element is fully visible OR scrolled right\r\n  if (xOffset >= 0) {\r\n    return xOffset + elementWidth <= ScreenWidth // is element fully visible?\r\n      ? elementWidth // element is fully visible;\r\n      : ScreenWidth - xOffset; // calculate visible width of scrolled element\r\n  }\r\n  // Element is scrolled LEFT\r\n\r\n  return elementWidth - xOffset; // calculate visible width of scrolled element\r\n};\r\n\r\n/*\r\ntype Coord = {\r\n  x: number,\r\n  y: number,\r\n};\r\n\r\n  ~Tooltip coordinate system:~\r\n  The tooltip coordinates are based on the element which it is wrapping.\r\n  We take the x and y coordinates of the element and find the best position\r\n  to place the tooltip. To find the best position we look for the side with the\r\n  most space. In order to find the side with the most space we divide the the\r\n  surroundings in four quadrants and check for the one with biggest area.\r\n  Once we know the quandrant with the biggest area it place the tooltip in that\r\n  direction.\r\n\r\n  To find the areas we first get 5 coordinate points. The center and the other 4 extreme points\r\n  which together make a perfect cross shape.\r\n\r\n  Once we know the coordinates we can get the length of the vertices which form each quadrant.\r\n  Since they are squares we only need two.\r\n*/\r\n\r\nconst getTooltipCoordinate = (\r\n  x,\r\n  y,\r\n  width,\r\n  height,\r\n  ScreenWidth,\r\n  ScreenHeight,\r\n  tooltipWidth,\r\n  tooltipHeight,\r\n  withPointer\r\n) => {\r\n  // The following are point coordinates: [x, y]\r\n  const center = [\r\n    x + getElementVisibleWidth(width, x, ScreenWidth) / 2,\r\n    y + height / 2,\r\n  ];\r\n  const pOne = [center[0], 0];\r\n  const pTwo = [ScreenWidth, center[1]];\r\n  const pThree = [center[0], ScreenHeight];\r\n  const pFour = [0, center[1]];\r\n\r\n  // vertices\r\n  const vOne = getPointDistance(center, pOne);\r\n  const vTwo = getPointDistance(center, pTwo);\r\n  const vThree = getPointDistance(center, pThree);\r\n  const vFour = getPointDistance(center, pFour);\r\n\r\n  // Quadrant areas.\r\n  // type Areas = {\r\n  //   area: number,\r\n  //   id: number,\r\n  // };\r\n\r\n  const areas = [\r\n    getArea(vOne, vFour),\r\n    getArea(vOne, vTwo),\r\n    getArea(vTwo, vThree),\r\n    getArea(vThree, vFour),\r\n  ].map((each, index) => ({ area: each, id: index }));\r\n\r\n  const sortedArea = areas.sort((a, b) => b.area - a.area);\r\n\r\n  // deslocated points\r\n  const dX = 0.001;\r\n  const dY = height / 2;\r\n\r\n  // Deslocate the coordinates in the direction of the quadrant.\r\n  const directionCorrection = [[-1, -1], [1, -1], [1, 1], [-1, 1]];\r\n  const deslocateReferencePoint = [\r\n    [-tooltipWidth, -tooltipHeight],\r\n    [0, -tooltipHeight],\r\n    [0, 0],\r\n    [-tooltipWidth, 0],\r\n  ];\r\n\r\n  // current quadrant index\r\n  const qIndex = sortedArea[0].id;\r\n\r\n  const getWithPointerOffsetY = () =>\r\n    withPointer ? 10 * directionCorrection[qIndex][1] : 0;\r\n  const getWithPointerOffsetX = () =>\r\n    withPointer ? center[0] - 18 * directionCorrection[qIndex][0] : center[0];\r\n\r\n  const newX =\r\n    getWithPointerOffsetX() +\r\n    (dX * directionCorrection[qIndex][0] + deslocateReferencePoint[qIndex][0]);\r\n\r\n  return {\r\n    x: constraintX(newX, qIndex, center[0], ScreenWidth, tooltipWidth),\r\n    y:\r\n      center[1] +\r\n      (dY * directionCorrection[qIndex][1] +\r\n        deslocateReferencePoint[qIndex][1]) +\r\n      getWithPointerOffsetY(),\r\n  };\r\n};\r\n\r\nconst constraintX = (newX, qIndex, x, ScreenWidth, tooltipWidth) => {\r\n  switch (qIndex) {\r\n    // 0 and 3 are the left side quadrants.\r\n    case 0:\r\n    case 3: {\r\n      const maxWidth = newX > ScreenWidth ? ScreenWidth - 10 : newX;\r\n      return newX < 1 ? 10 : maxWidth;\r\n    }\r\n    // 1 and 2 are the right side quadrants\r\n    case 1:\r\n    case 2: {\r\n      const leftOverSpace = ScreenWidth - newX;\r\n      return leftOverSpace >= tooltipWidth\r\n        ? newX\r\n        : newX - (tooltipWidth - leftOverSpace + 10);\r\n    }\r\n    default: {\r\n      return 0;\r\n    }\r\n  }\r\n};\r\n\r\nexport default getTooltipCoordinate;\r\n"]},"metadata":{},"sourceType":"module"}